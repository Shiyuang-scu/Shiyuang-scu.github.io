# C++ 技巧

变量定义指定了变量的类型和标识符，也可以为对象提供初始值。定义时制定了初始值的对象被成为是`已初始化的（initialized）`。C++支持两种初始化变量的形式：`复制初始化（copy－initialization）`和`直接初始化（direct－initialization）`。复制初始化语法用等号，直接初始化则是把初始化式放在括号中

    int ival（1024）； //direct-initialization
    int ival = 1024；    //copy-initialization

C++中初始化和赋值是两种不同的操作，请注意。并且直接初始化语法更灵活而且效率更高。

---

定义如何进行初始化的成员函数称为`构造函数（constructor）`。和其他函数一样，构造函数能接受多个参数。一个类可以定义几个构造函数，每个构造函数必须接受不同数目或者不同类型的参数。

---

内置类型（如int）变量是否自动初始化取决于变量定义的位置。在函数体外定义的变量都初始化为0，在函数体里定义的内置类型变量不进行自动初始化。除了用作赋值操作符的左操作数，未初始化变量用作任何其他用途都是没有定义的。未初始化变量引起的错误难以发现，永远不要依赖未定义行为。

---

建议每个内置类型的对象都要初始化。虽然这样做并不总是必需的，但是会更加容易和安全，除非你确定忽略初始化式不会带来风险。

---

如果定义某个类的变量时没有提供初始化式，这个类也可以定义初始化时的操作。它是通过定义一个特殊的构造函数即`默认构造函数（default constructor）`来实现的。如果没有提供初始化式，那么就会使用默认构造函数。不管变量在哪里定义，默认构造函数都会被使用。

---

`变量的定义（definition）`用于为变量分配存储空间，还可以为变量指定初始值。在一个程序中，变量有且仅有一个定义。`声明（declaration）`用于项程序表明变量的类型和名字。定义也是声明；当定义变量时我们声明了它的类型和名字。可以通过使用`extern`关键字声明变量而不定义它。不定义变量的声明包括对象名。对象类型和对象类型前的关键字`extern`。

---

在C++语言中，变量必须且仅能定义一次，而且在使用变量之前必须定义或者声明变量。

---

用来区分名字的不同意义的上下文称为`作用域（scope）`。作用域是程序的一段区域。一个名称可以和不同作用域中的不同实体相关联。C++语言中，大多数作用域是用花括号来界定的。一般来说，名字从其声明点开始直到其声明所在的作用域结束处都是可见的。

---

定义在所有函数外部的名字具有`全局作用域（global scope）`，可以在程序中的任何地方访问。定义在`main`函数的作用域，则在整个`main`函数中可以使用，具有`局部作用域（local scope）`。而在某个语句中定义的（例如for语句中），则只能在语句中使用，具有`语句作用域（statement scope）`。

---

C++中作用域可嵌套，若先定义了全局变量s1，而又在main中定义了局部变量s1，那么，局部变量s1就会屏蔽全局变量s1。要注意的是，像上面这样的定义方法很可能让他人大惑不解，同名总是不好的，建议局部变量最好使用不同的名字。

---

一般来说，变量的定义或声明可以放在程序中能摆放语句的任何位置。变量在使用前必须先声明或定义。通常把一个对象定义在它首次使用的地方是一个很好的办法。

---

定义一个变量代表某一常数的方法仍然有一个严重的问题。此变量是可以被修改的。`const`限定符提供了一个解决办法，它把一个对象转换成一个常量。如下：

    const int bufsize ＝ 512；

此时变量`bufsize`是不可修改的，任何修改`bufsize`的尝试都会导致编译错误。因为常量在定义后就不能被修改，所以定义时必须初始化。

---

`const`对象默认为文件的局部变量，此变量只存在于那个文件中，不能被其他文件访问。非`const`变量默认为`extern`。要使`const`变量能够在其他文件中访问，必须显式地指定它为`extern`。

---

`引用（reference）`就是对象的另一个名字。在实际程序中，引用主要用作函数的形式参数。引用式一种`复合类型（compound type）`，通过在变量名前添加`&`符号来定义。复合类型是指用其他类型定义的类型。在引用的情况下，每一种引用类型都“关联到”某一其他类型。不能定义引用类型的引用，但可以定义其他任何类型的引用。引用必须用与该引用同类型的对象初始化：

    int ival ＝ 1024；
    int &refVal = ival; //ok: refVal refers to ival
    int &refVal2;       //error: a reference must be initialized
    int &refVal3 = 10;  //error: initializer must be an object

---

引用只是它绑定的对象的另一个名字，作用在引用上的所有操作事实上都是作用在该引用绑定的对象上。当引用初始化后，只要该引用存在，它就保持绑定到初始化时指向的对象。不可能将引用绑定到另一个对象。

---
const引用是指向const对象的引用

    const int ival ＝ 1024；
    const int &refVal = ival;   //ok: both reference and object are const
    int &ref2 = ival;       //error: nonconst reference of a const object

可以读取但是不能修改refVal，任何对refVal的赋值都是不合法的。同理，用ival初始化ref2也是不合法的：ref2是普通的非const引用（nonconst reference）。

---

const引用可以初始化为不同类型的对象或者初始化为右值，如字面值常量：

    int i = 42;
    // legal for const references only
    const &r = 42;
    const &r2 = r + i;

同样的初始化对于非const引用却是不合法的，而且会导致编译时错误。这里稍微解释一下

    double dval = 3.14;
    const int &ri = dval;

编译器会把这些代码转换成如以下形式的编码：

    int temp = dval;     // create temporary int from the double
    const int &ri = temp;   // bind ri to that temporary

如果`ri`不是`const`，那么可以给`ri`赋一个新值。这样做不会修改dval，而是修改了temp。期望对ri的赋值会修改dval的程序员会发现dval并没有被修改。仅允许const引用绑定到需要临时使用的值完全避免了这个问题，因为const引用是只读的。

18、typedef可以用来定义类型的同义词：
    typedef double wages;   // wages is a synonym for double
    typedef int exam_score; // exam_score is a synonym for int
typedef名字可以用作类型说明符：
    wages hourly,  weekly;  // double hourly, weekly;
19、typedef通常被用于以下三种目的：为了隐藏特定类型的实现，强调使用类型的目的；简化复杂的类型定义，使其更易理解；允许一种类型用于多个目的，同时使得每次使用该类型的目的明确。

20、枚举的定义包括关键字 enum，其后是一个可选的枚举类型名，和一个用花括号括起来、用逗号分开的枚举成员（enumerator）列表。
    // input is 0, output is 1, and append is 2
    enum open_mode {input, output, append};
 默认地，第一个枚举成员赋值为0，后面地每个枚举成员赋的值比前面的大1。
    //shape is 1, sphere is 2, cylinder is 3, polygon is 4
    enum Forms {shape = 1, sphere, cylinder, polygon};
枚举成员值可以是不唯一的。每个enum都定义一种唯一的类型。

21、每个类都定义了一个接口（interface）和一个实现（implementation）。接口由使用该类的代码需要执行的操作组成。实现一般包括该类所需要的数据。实现还包括定义该类需要的但又不供一般性使用的函数。定义类时，通常先定义该类的接口，即该类所提供的操作，可以决定该类完成其功能所需要的数据，以及是否需要定义一些函数来支持该类的实现。

22、类定义以关键字class开始，其后是该类的名字标识符。类体位于花括号里面。花括号后面必须要跟一个分号。类体可以为空，类体定义了组成该类型的数据和操作。这些操作和数据是类的一部分，也称为类的成员（member）。操作称为成员函数，而数据则称为数据成员（data member）。

23、用class和struct关键字定义类的唯一差别在于默认访问级别：默认情况下，struct的成员为public，而class的成员为private。

24、因为头文件包含在多个源文件中，所以不应该含有变量或函数的定义。如果const变量不是用常量表达式初始化，那么它就不应该在头文件定义。相反，和其他的变量一样，该const变量应该在一个源文件中定义并初始化。应在头文件中为它添加extern声明，以使其能被多个文件共享。

25、使得头文件安全的通用做法，是使用预处理器定义头文件保护符（header guard）。
    #ifndef someheader.h
    #define someheader.h
    #endif
头文件应该含有保护符，即使这些头文件不会被其他头文件包含。编写头文件保护符并不困难，而且如果头文件被包含多次，它可以避免难以理解的编译错误。



26、C++提供了更简洁的方式来使用命名空间成员。这里介绍一种最安全的机制：using声明。形式为：using namespace：：name；
    #include <string>
    #include <iostream>
    using std::cin;
    using std::cout;
    int main()
    {
    .......
    }

27、一个using声明一次只能作用于一个命名空间成员。每个名字都需要一个using声明。

28、标准库string类型支持长度可变的字符串。一般的声明格式如下：
    #include <string>
    using std::string;
string标准库支持几个构造函数，如下：
    string s1；              默认构造函数，s1为空串
    string s2（s1）；          将s2初始化为s1的一个副本
    string s3（“value”）；     将s3初始化为一个字符串字面值副本
    string s4（n，‘c’）；       将s4初始化为字符‘c’的n个副本
※※※因为历史原因以及为了与C语言兼容，字符串字面值与标准库string类型不是同一种类型，编程时一定要注意区别。

29、string类型的输入操作符：读取并忽略开头所有的空白字符（如空格，换行符，制表符）；读取字符直至再次遇到空白字符，读取中止。

30、读入未知数目的string对象
    while(cin >> word)
        cout << word << endl;

31、用getline读取整行文本，该函数接受两个参数：一个输入流对象和一个string对象。getline函数从输入流的下一行读取，并保存读取的内容到string中，但不包括换行符。
    string line;
    while (getline(cin, line))
        cout << line << endl;
因为line不含换行符，如果需要逐行输出则需要自行添加。

32、VC 6和Xcode中对于getline的使用都存在bug。具体的表现是VC6里要输入两次回车才能输出，而Xcode的出错则是释放了未分配的指针。具体的解决方案如下
VC6：
X:\Program Files\Microsoft Visual Studio\VC98\Include\string(注意是string文件，不是string.h)找到165行，下面的代码从163行开始
    else if (_Tr::eq((_E)_C, _D)) //163行
    {_Chg = true;
    //  _I.rdbuf()->snextc(); // 把这一行注释掉,添加下一行.
    _I.rdbuf()->sbumpc(); //添加
    break;}


Xcode：有两种方案，其实差不多，第一种是在代码最前面加上
#define _GLIBCXX_FULLY_DYNAMIC_STRING 1 
#undef _GLIBCXX_DEBUG 
#undef _GLIBCXX_DEBUG_PEDANTIC
第二种如下：
The solution is to double-click on the target to open its Info window, go to the Build tab, and scroll down to the "GCC 4.2 - Preprocessing" section. In this section is a setting named "Preprocessor Macros" that by default has two entries, "_GLIBCXX_DEBUG=1" and "_GLIBCXX_DEBUG_PEDANTIC=1". Remove these entries.

33、string的size和empty操作。可以通过size操作获取。
    int main(){
        string st(“The expense of spirit\n”);
        cout <<  “The size of ” <<  st <<  “is ” <<  st.size() << endl;
        return 0;}
empty成员函数将返回bool值，如果string对象为空则返回ture，否则返回false。

34、size操作返回的是string::size_type类型的值。string类类型和许多其他库类型都定义了一些配套类型（companion type）。通过这些配套类型，库类型的使用就能与机器无关（machine－independent）。size_type就是这些配套类型的一种。定义为与unsigned型具有相同的含义，而且可以保证足够大能够存储任意string对象的长度。为了使用类型定义的size_type类型，程序员必须加上作用域操作符来说明所使用的size_type类型是由string类定义的。即std::size_type类型。不要把size的返回值赋给int变量！

35、对string对象来说，可以把一个string对象赋值给另一个string对象。string对象的加法被定义为（concatenation）。如下
    string s1(“hello, ”);
    string s2(“world\n”);
    string s3 = s1 + s2;        // s3 is hello, world\n
如果要把s2直接追加到s1的末尾，就用＋＝
    s1 += s2;

36、当进行string对象和字符串字面值混合连接操作时，＋操作符的左右操作数必须至少有一个是string类型的：
    string s4 = “hello” + “, ”;     // error: no string operand
    string s5 = s1 + “, ” + “world ”;   // ok: each + has string operand
    string s6 = “hello” + “,” + s2; // error: can’t add string literals
顺序是从左到右的，所以s5中的s1先和第二个加，还是string类型，然后和第二个加；而s6中的第一个和第二个相加就不满足条件了。

37、string类型通过下标操作符（ [] ）来访问string对象中的单个字符。下标操作符需要取一个size_type类型的值，来标明要访问字符的位置。着下标中的值通常被称为“下标”或“索引（index）”。string对象的下标从0开始而s[s.size()-1]就是最后一个字符。

38、string对象中字符的处理通常都在在cctype头文件中定义。如果把某个字符赋值为‘\0’，则用cout输出时会自动略过，具体可看下图：
39、vector是同一种类型的对象的集合，每个对象都有一个对应的整数索引值。我们把vector称为容器，是 因为它可以包含其他对象。一个容器中的所有对象都必须是同一种类型的。在使用vector之前，必须包含相应的头文件。声明如下
    #include <vector>
    using std::vector;

40、vector是一个类模板（class template）。使用模板可以编写一个类定义或函数定义，而用于多个不同的数据类型。声明从类模板生产的某种类型的对象，需要提供附加信息，信息的种类取决于模板。以vector为例，必须说明vector保存何种对象的类型，通过将类型放在类模板名称后面的尖括号中来指定类型：
    vector<int> ivec;               // ivec holds objects of type int
    vector<Sales_item> Sales_vec        // holds Sale_itmes
和其他变量定义一样，定义vector对象要指定类型和一个变量的列表。上面的第一个定义，类型是vector<int>，该类型即是含有若干int类型对象的vector，变量名为ivec。

41、vector不是一种数据类型，而只是一个类模板，可用来定义多种数据类型。vector类型的每一种都指定了其保存元素的类型。因此，vector<int>和vector<string>都是数据类型。

42、vector对象的初始化方式
    vector<T>  v1；          vector保存类型为T的对象，默认构造函数v1为空
    vector<T>  v2；          v2是v1的一个副本
    vector<T>  v3（n，i）；     v3包含n个值为i的元素
    vector<T>  v4（n）；       v4含有值初始化的元素的n个副本

43、vector对象（以及其他标准库容器对象）的重要属性就在于可以在运行时高效地添加元素。因为vector增长地效率高，在元素值已知的情况下，最好是动态地添加元素。

44、vector对象的size
    empty和size操作类似于string类型的相关操作。成员函数size返回相应vector类定义的size_type值。使用size_type类型时，必须指出该类型时在哪里定义的。vector类型总是包括vector的元素类型：
    vector<int>::size_type      // ok
    vector::size_type           // error

45、向vector添加元素。push_back()操作接受一个元素值，并将它作为一个新的元素添加到vector对象的后面。
    // read words from the standard input and store them as elements in vector
    string word;
    vector<string> text;                // empty vector
    while(cin >> word){
        text.push_back(word);       // append word to text
    }

46、vector中的对象是没有命名的壳以按vector中对象的位置来访问它们。通常使用下标操作符来获取元素。vector元素的位置从0开始。

47、必须是已存在的元素才能用下标操作符进行索引。通过下标操作进行赋值时，不会添加任何元素。如果想要插入新元素，写法如下：
    for (vector<int>::size_type ix = 0; ix != 10; ++ix)  //这样的话就保证了索引和实际一致
        ivec.push_back(ix);

48、除了使用下标来访问vector对象的元素外，标准库还提供了另外一种访问元素的方式：使用迭代器（iterator），迭代器时一种检查容器内元素并遍历元素的数据类型。标准库为每一种标准容器（包括vector）定义了一种迭代器类型。迭代器类型提供了比下标操作更通用化的方法：所有的标准库容器都定义了相应的迭代器类型，而只有少数的容器支持下标操作。因此，现代C++程序更倾向于使用迭代器而不是下标来访问容器元素。

49、容器的iterator类型，定义如下（以vector为例）
    vector<int>::iterator iter；
每种容器都定义了一对名为begin和end的函数，用于返回迭代器。如果容器中有元素的话，由begin返回的迭代器指向第一个元素：
    vector<int>::iterator iter ＝ ivec.begin();
上述语句把iter初始化为ivec[0]。由end操作返回的迭代器指向vector的“末端元素的下一个”。通常称为超出末端迭代器（off－the －end iterator），只是起一个哨兵（sentinel）的作用，表示我们已经处理完了vector中的所有元素。

50、迭代器可以使用解引用操作符（*操作符）来访问迭代器所指向的元素
    *iter ＝ 0；  //即把iter当前指向的元素赋值为0
迭代器使用自增操作符向前移动迭代器指向容器中的下一个元素。
※※※由于end操作返回的迭代器不指向任何元素，因此不能对它进行解引用或自增操作。

51、用 == 或者 != 操作符来比较两个迭代器，如果两个迭代器对象指向同一个元素，则它们相等，否则就不相等。

52、应用迭代器来编写的初始化为0的循环
    for(vector<int>::iterator iter = ivec.begin(); iter != ivec.end(); ++iter )
        *iter = 0;

53、若定义为const_iterator类型，就只能用于读取容器内元素，但不能改变其值。而如果时const的iterator对象，那么这个迭代器就不能改变，这样基本就无用的。下面是一个const_iterator的例子：
    for(vector<string>::const_iterator iter = text.begin(); iter != text.end(); ++iter)
        cout <<  *iter << endl;

54、迭代器的算术操作（iterator arithmetic）：iter ＋ n与 iter － n。iter1 － iter2 用来计算两个迭代器对象的距离，该距离时名为difference_type的signed类型的值。例如求最靠近正中的元素，可用以下代码：
    vector<int>::iterator mid = vi.begin() + vi.size()/2;
※※※任何改变vector长度的操作都会使已存在的迭代器失效。例如，在调用push_back后，就不能再信赖指向vector的迭代器的值了。

55、标准库bitset类型可以用来处理二进制位的有序集，可以使用bitset处理，声明如下：
    #include <bitset>
    using std::bitset;

56、类似于vector，bitset类是一种类模板；而与vector不一样的是bitset类型对象的区别仅在其长度而不在其类型。定义bitset时，要明确bitset含有多少位，要在尖括号内给出它的长度值：
    bitset<32> bitvec;  // 32 bits, all zero
长度值必须定义为整型字面值常量或者是已用常量值初始化的整型的const对象。bitset中的位是没有命名的，程序员只能按位置访问。位集合的位置编号从0开始，以0位开始的位串是低阶位（low-order bit），以31位结束的位串是高阶位（high-order bit)。
57、用unsigned值初始化bitset对象时，该值将转化为二进制的位模式。而bitset对象中的位集作为这种位模式的副本。如果bitset类型长度大于unsigned long值的二进制位数，则其余的高阶位将置为0；如果小于，则只使用unsigned值中的低阶位，其余的被丢弃。

58、用string对象初始化bitset对象时，string对象直接表示为位模式。从string对象读入位集的顺序时从右向左：
    string strval(“111000”);
    bitset<32> bitvec4(strval);
那么这时bitvec4的表示为：0000000000···000111（共32位）
    string str（“1111111000000011001101”）；
    bitset<32> bitvec5(str, 5, 4);      //从str[5]开始的4个位。即1100
    bitset<32> bitvec6（str，str.size()-4）    //取最后的四位。即1101

59、现代C++程序应尽量使用vector和迭代器类型，而避免使用低级的数组和指针。设计良好的程序只有在强调速度时才在类实现的内部使用数组和指针。指针和数组容易产生不可预料的错误。其中一部分是概念上的问题：指针用于低级操作，容易产生与繁琐细节相关的（bookkeeping）错误。其他错误则源于使用指针的语法规则，特别是声明指针的语法。许多有用的程序都可不使用数组或指针实现，现代C++采用vector类型和迭代器取代一般的数组、采用string类型取代C风格字符串。

60、如果可能的话，除非所指向的对象已经存在，否则不要先定义指针，这样可以避免定义一个未初始化的指针。如果必须分开定义指针和其所指向的对象，则将指针初始化未0。因为编译器可检测出0值的指针，程序可判断该指针并未指向一个对象。

61、C++提供了一种特殊的指针类型void*，它可以保存任何类型对象的地址。void*表明改指针与一地址值相关，但不清楚存储在此地址上的对象的类型。void*指针只支持几种有限的操作：与另一个指针进行比较；向函数传递void*指针或从函数返回void*指针；给另一个void*指针赋值。不允许使用void*指针操纵它所指向的对象。

62、如果对左操作数进行解引用，则修改的是指针所指对象的值；如果没有使用解引用操作，则修改的是指针本身的值。

63、如果指针指向const对象，则不允许用指针来改变其所指的const值。为了保证这个特性，C++语言强制要求指向const对象的指针也必须具有const特性：
    const double *cptr ;        // cptr may point to a double that is const
这里cptr是一个指向double类型const对象的指针，const限定了cptr指针所指向的对象类型，而并非cptr本身。也就是说cptr本身并不是const（这里推荐从右向左读以上语句，就可以理解为cptr指向一个const的double类型）。在定义的时候不需要初始化，也可以对其重新赋值，但不能通过cptr修改其所指向对象的值；把你个const对象的地址赋给一个普通的、非const对象的指针也会导致编译时的错误；不能使用void*指针保存const对象的地址，而必须使用const void*类型的指针保存const对象的地址；允许把const对象的地址赋给指向const对象的指针。

64、不能使用指向const对象的指针修改基础对象，然后如果该指针指向的是一个非const对象，可用其他方法修改其所指的对象。
    const double *cptr;
    dval = 3.14159;     // dval is not const
    *cptr = 3.14159;        // error: cptr is a pointer to const
    double *ptr = &dval;        // ok: ptr points at non-const double
    *ptr = 2.72;            // ok: ptr is plain pointer
    cout << *cptr;          // ok: prints 2.72
65、从本质上说，由于没有方法分辨cptr所指的对象是否为const，系统会把它所有对象都视为const。如果指向const的指针所指的对象并非const，则可直接给该对象赋值或间接地利用普通地非const指针修改其值：毕竟这个值不是const。就是说不能保证指向const地指针所指对象的值一定不能修改。

66、C++还提供了const指针——本身的值不能修改。任何企图给const指针赋值的行为（即使是赋同样的值）都会导致编译时的错误。定义方式如下：
    const double pi ＝ 3.14159；
    const double *const pi_ptr = & pi;
    // pi_ptr is const and points to a const object

67、C风格字符串（C-style character string）是以空字符null结束的字符数组。尽管C++支持C风格字符串，但不应该在C++程序中使用这个类型。C风格字符串常常带来许多错误，是导致大量安全问题的根源。

68、可以这么样利用循环测试C风格字符串：
    const char *cp = “some value”;
    while (*cp){
    ++cp；//注意一定是C风格字符串，因为这样才能保证结尾是null，否则不能结束
    }

69、用关系操作符（> < ==）来比较C风格字符串时，比较的时指针上存放的地址值，而不是它们所指向的字符串。

70、调用者必须确保目标字符串具有足够的大小，但是却有潜在的严重错误。如果必须使用C风格字符串，strncat和strncpy比strcat和strcpy函数更安全。诀窍就是可以适当地控制复制字符地个数。特别是在复制和串联字符串时，一定要时刻记住算上结束符null。所以尽可能使用标准库类型string，不但安全性增强了，效率也提高了。


71、数组类型的变量有三个重要的限制：数组长度固定不变，在编译时必须直到其长度，数组只有在定义它的块语句内存在。每一个程序在执行时都占用一块可用的内存空间，用于存放动态分配的对象，此内存空间称为程序的自由存储区（free store）或堆（heap）。C语言程序使用一对标准库函数malloc和free在自由存储区中分配存储空间，而C++语言则使用new和delete表达式实现相同的功能。

72、允许动态分配空数组（编译的时候并不知道数组的长度）。可以用以下代码实现
    size_t n = get_size()   // get_size returns of elements needed
    int* p = new int[n];
    for(int* q = p; q !=p+n; ++q)
    .........(可见ex3.17-3.21)
有趣的是，即使get_size返回的是0，代码依然可以正确执行。C++虽然不允许定义长度为0的数组变量，但明确指出，调用new动态创建长度为0的数组是合法的，返回有效的非零指针。

73、动态分配的内存最后必须进行释放。C++为指针提供了delete []表达式释放指针所指向的数组空间。如 delete [ ] pia；就回收了pia指向的数组。如果遗漏了空方括号对，就无法告诉编译器该指针指向的是数组，将导致程序在运行时出错。

74、使用数组初始化vector对象，必须指出用于初始化式的第一个元素以及数组最后一个元素的下一位置的地址：
    const size_t arr_size = 6;
    int int_arr[arr_size] = {0,1,2,3,4,5};
    // ivec has 6 elements: each a copy of the corresponding element in int_arr
    vector<int> ivec(int_arr, int_arr + arr_size);
传递给ivec的两个指针标出了vector初值的范围。第二个指针指向被复制的最后一个元素之后的地址空间。

75、用typedef简化指向多维数组的指针
    typedef int int_array[4];
    int_array *ip = ia;
    for (int_array *p = ia; p != ia + 3; ++p)
        for(int *q = *p; q != *p + 4; ++q)
            cout << *q << endl;

76、逻辑与和逻辑或操作符总是先计算其左操作数，然后再计算其右操作数。只有仅靠左操作数的值无法确定该逻辑表达式的结果时，才会求解其右操作数。我们称这种求值策略为“短路求值（short-circuit evaluation）”。这么就引出了一个很有价值的用法：如果某边界条件使expr2的计算变得危险，那么显然expr1的计算结果为false。（expr1 &&(||)expr2）

77、不应该串接使用关系操作符，虽然是左结合，但是由于其返回bool类型的结果，如果多个关系操作符串接起来使用，结果往往出乎意料。

78、val本身是bool类型，或者val具有可转换为bool类型的数据类型。如果val是bool类型，那么if（val == true ）等价于 if（val）。
若val不是bool值，val和true的比较等效于 if （val == 1）



79、位操作符使用整型的操作数。位操作符将其整型操作数视为二进制位的集合，为每一位提供检验和设置的功能（也可用于bitset类型）。位操作符操纵的整数的类型可以是有符号的也可以是没有符号的。如果操作数为负数，具体的处理情况就要依照机器的情况来判定，所以保险起见，用unsigned整型操作数。

80、一般而言，标准库提供的bitset操作更直接，更容易阅读和书写、正确使用的可能性更高。而且，bitset对象的大小不受unsigned数的位数限制。通常来说，bitset优于整形术句的低级直接位操作。

81、在赋值操作上加圆括号是必需的，因为赋值操作符的优先级低于不等操作符。


82、对于for循环来说，例如：for（语句1；条件；增殖）这样的，先执行语句1，再判断是否满足条件，满足的话执行完循环体，再进行增殖，这里使用++i与i++的效果是一样的。但是只有再必要时才使用后置操作符（i++），因为前置操作需要做的工作更少。只需加1后返回加1后的结果即可。而后置操作符则必须先保存操作数原来的值，以便返回未加1之前的值作为操作的结果。对于int型对象和指针，编译器可优化掉这项额外工作。但是对于更多的复杂迭代器类型，这种额外工作可能花费更大的代价。因此，养成使用前置操作这个好习惯，就不必担心性能差异的问题。

83、sizeof操作符的作用是返回一个对象或类型名的长度，返回值的类型为size_t，长度的单位是字节。sizeof表达式的结果是编译时常量。

84、 对char类型或值为char类型的表达式做sizeof操作保证得1。
    对引用类型做sizeof操作将返回存放此引用类型对象所需的内存空间大小。
        对指针做sizeof操作将返回存放指针所需的内存大小；注意，如果要获取该指针所指向的对象的大小，则必须对该指针进行解引用。
    对数组做sizeof操作等效于将对其元素类型做sizeof的结果乘上数组元素的个数。所以用sizeof数组的结果除以sizeof其元素类型的结果，即可求得数组元素的个数。

85、逗号表达式是一组由逗号分隔的表达式，这些表达式从左向右计算。逗号表达式的结果是其最右边表达式的值。

86、含有两个或更多操作符的表达式称为复合表达式（compound expression）。在复合表达式中，操作数和操作符的结合方式决定了整个表达式的值。表达式的结果会因为操作符和操作数的分组结合方式的不同而不同。操作数的分组结合方式决定了整个表达式的值。表达式的结果会因为操作符和操作数的分组结合方式的不同而不同。优先级规定的是操作数的结合方式，但并没有说明操作数的计算顺序。在大多数情况下，操作数一般以最方便的次序求解。

87、以下两个指导原则有助于处理复合表达式：
（1）如果有怀疑，则在表达式上按程序逻辑要求使用圆括号强制操作数的组合。
（2）如果要修改才做数的值，则不要在同一个语句的其他地方使用该操作数。如果必须使用改变的值，则把该表达式分割成两个独立语句：在一个语句中改变操作数的值，再在下一个语句使用它。
※※※一个表达式里，不要在两个或更多的子表达式中对同一对象做自增或自减操作。


88、定义变量时，必须指定其数据类型和名字。而动态创建对象时，只需指定其数据类型，而不必为该对象命名。取而代之的是，new表达式返回指向新创建对象的指针，我们通过该指针来访问此对象：
    int *pi = new int;  //pi points to dynamically allocated, unnamed, uninitialized int
这个new表达式在自由存储区中分配创建了一个整型对象，并返回此对象的地址，并用该地值初始化指针pi。

89、动态创建的对象可用初始化变量的方式实现初始化：
    int *pi = new int(1024);        // object to which pi points is 1024
    string *ps = new string(10, ‘9’);   // *ps is “9999999999”
正如我们（几乎）总是要初始化定义为变量的对象一样，在动态创建对象时，（几乎）总是对它做初始化也是一个好办法。

90、动态创建的对象用完后，程序员必须显式地将该对象占用地内存返回给自由存储区。可以使用delete表达式释放指针所指向地地址空间。如：
    delete pi；该命令释放pi指向的int型对象占用的内存空间。
※※※若指针指向不是用new分配的内存地址，则在该指针上使用delete是不合法的。C++没有明确定义如何释放指向不是用new分配的内存地址的指针。

91、执行语句 delete p；之后，p变成没有定义。在很多机器上，尽管p没有定义，但仍然存放了它之前所指向的地址，然而p所指向的内存已经被释放，因此p不再有效。删除指针后，该指针变成悬垂指针（dangling pointer）。悬垂指针指向曾经存放对象的内存，但该对象已经不再存在了。悬垂指针往往导致程序错误，而且很难检测出来。
※※※一旦删除了指针所指向的对象，立即将指针置为0，这样就非常清楚地表明指针不再指向任何对象。

92、const对象地动态分配和回收
    const int *pic = new const int(1024);
动态创建的const对象必须在创建时初始化，并且一经初始化，其值就不能修改。
    delete pic；// ok: deletes a const object

93、将enum对象或枚举成员提升为什么类型由机器定义，并且依赖于枚举成员的最大值。无论其最大值时什么，enum对象或枚举成员至少提升为int型。

94、当使用非const对象初始化const对象的引用时，系统将非const对象转化为const对象。此外，还可以将非const对象的地址（或非const指针）转换为const类型的指针。

95、显式转换也称为强制类型转换（cast），包括以下名字命名的强制类型转换操作符：static_cast、dynamic_cast、const_cast和reinterpret_cast。
※※※虽然有时候确实需要强制类型转换，但是它们本质上是非常危险的。

96、因为要覆盖通常的标准转换，所以需要显式使用强制类型转换
    double dval;
    int ival;   //这里要先将ival转换称double型，然后再把double型的结果
    ival *= dval;   //截取为int型，再赋值给ival。
为了去掉这个不必要的转换，可以强制将ival转换为int型
    ival *= static_cast<int>(dval);
※※※显式使用强制类型转换的另一个原因是可能存在多种转换，需要选择一种特定的类型转换。

97、const_cast，将转换掉表达式的const性质。dynamic_cast支持运行时识别指针或引用所指向的对象。reinterpret_cast通常为操作数的位模式提供较低层次的重新解释。
※※※reinterpret_cast本质上依赖于机器。为了安全地使用reinterpret_cast，要求程序员完全理解所设计地数据类型，以及编译器实现强制类型转换的细节。

98、编译器隐式执行的任何类型转换都可以由static_cast显式完成
    double d = 97.0;
    char ch = static_cast<char>(d);
当需要将一个较大的算术类型赋值给较小的类型时，使用强制转换非常有用。此时强制类型转换告诉程序的读者和编译器：我知道并且不关心潜在的精度损失。这样警告信息就会消失。如果编译器不提供自动转换，使用static_cast来执行类型转换也是很有用的。例如下面的程序使用static_cast找回存放在void*指针中的值：
    void *p = &d;
    double *dp = static_cast<double*>p;

99、强制类型转换关闭或挂起了正常的类型检查。强烈建议程序员避免使用强制类型转换，不依赖强制类型转换也能写出很好的C++程序。这个建议再如何看待reinterpret_cast的使用时非常重要。此类强制转换总是非常危险的。相似地，使用const_cast也总是预示着设计缺陷。设计合理的系统不需要使用强制类型转换抛弃const特性。如果非强制转换不可，则应限制强制转换值的作用域，并且记录所有假定涉及的类型，这样能减少错误发生的机会。

100、如果在程序的某个地方，语法上需要一个语句，但逻辑上并不需要，此时应该使用空余句。这种用法常见于在循环条件判断部分就能完成全部循环工作的情况。
※※※使用空语句时应该加上注释，以便任何读这段代码的人都知道该语句是有意义的。

101、在条件表达式中定义的变量必须初始化，该条件检验的就是初始化对象的值。这种变量的作用域限制在语句体内。通常，语句体本身就是一个块语句，其中也可能包含了其他的块。一个在控制结构里引入的名字是该语句的局部变量，其作用域限在语句内部。

102、很多编辑器和开发环境都提供工具自动根据语句结构缩排源代码。有效地利用这些工具将是一种很好的编程方法。

103、所有语言的if语句普遍存在着潜在的二义性。这种情况往往称为悬垂else（dangling-else）问题，C++中悬垂else问题带来的二义性，通过将else匹配给最后出现的尚未匹配的if子句来解决。

104、尽管没有严格要求在switch结构的最后一个标号之后指定break语句，但是，为了安全起见，最好在每个标号后面提供一个break语句，即使是最后一个标号也一样。如果以后在switch结构的末尾又需要添加一个新的case标号，则不用再前面添加break语句了。
※※※故意省略case后面的break语句是很罕见的，因此应该提供一些注释说明其逻辑。

105、default标号（default label）提供了相当于else子句的功能。如果所有的case标号与switch表达式的值都不匹配，并且default标号存在，则执行default标号后面的语句。哪怕没有语句要在default标号下执行，定义default标号仍然是有用的。定义default标号是为了告诉它的读者，表明这种情况已经考虑到了，只是没有什么要执行的。

106、再循环条件中定义的变量再每次循环里都要经历创建和撤销的过程。

107、do while循环保证循环体至少执行一次，并且总是以分号结束。

108、goto语句提供了函数内部的无条件跳转，实现从goto语句跳转到同一函数内某个带标号的语句。语法规则位：    goto label； 其中label是用于标识带标号的语句的标识符。再任何语句前提供一个标识符和冒号，即得带标号得语句（labeled statement）：
    end： return；    // labeled statement, may be target of a goto
goto语句不能跨越变量得定义语句向前跳转：
    //  ...
    goto end;
    int ix = 10;        // error: goto bypasses declaration statement
end:
    // error: code here could use ix but the goto bypassed its declaration
    ix =  42;
如果确实需要再goto和其跳转对应得标号之间定义变量，则定义必须放在一个块语句中：
    // ...
    goto end;
    {
        int ix = 10;
        // ...code using ix
    }
   end: // ix no longer visible here
向后跳过已经执行得变量定义语句是合法的。

109、再涉及各种软件系统的过程中，处理程序中的错误和其他反常行为是最困难的部分之一。异常就是运行时出现的不正常，例如运行时耗尽了内存或遇到意外的非法输入。异常存在于程序的正常功能之外，并要求程序立即处理。在设计良好的系统中，异常是程序错误处理的一部分。当程序代码检查到无法处理的问题时，异常处理就特别有用。在这些情况下，检测出问题的那部分程序需要一种方法把控制权转到可以处理这个问题的那部分程序。错误检测程序还必须指出具体出现了什么问题，并且可能需要提供一些附加信息。

110、异常机制提供程序中错误检测与错误处理部分之间的通信。C++的异常处理中包括：
    throw表达式（throw expression），错误检测部分使用这种表达式来说明遇到了不可处理的错误。可以说，throw引发（raise）了异常条件。
    try块（try block），错误处理部分使用它来处理异常。try语句块以try关键字开始，并以一个或多个catch子句（catch clause）结束。在try块中执行的代码所抛出（throw）的异常，通常会被其中一个catch子句处理。由于它们“处理”异常，catch子句也称为处理代码（handler）
    由标准库定义的一组异常类（exception class），用来在throw和相应的catch之间传递有关的错误信息。

111、系统通过throw表达式抛出异常。throw表达式由关键字throw以及尾随的表达式组成，通常以分号结束，这样它就称为了表达式语句。throw表达式的类型决定了所抛出异常的类型。下面是用throw抛出异常来改写检测代码(判断是否是同一本书，如果不是就输出信息并退出)：
    // first check that data is for the same item
    if(!item1.same_isbn(item2))
        throw runtime_error(“Data must refer to same ISBN”);
    // ok, if we’re still here the ISBNs are the same
    std::cout << item1 + item2 << std::endl;
throw语句使用了一个表达式。这里是用的是runtime_error类型的对象，此类型是标准库异常类中的一种，在stdexcept头文件中定义，这样就可以提供更多相关信息。

112、try块的通用语法形式是：
    try{
        program-statements
    } catch (exception-specifier){
        handler-statements
    } catch (exception-specifier){
        handler-statements
    }   //......
try块以关键字try开始，后面是用花括号括起来的语句序列块。try块后面是一个或多个catch子句。每个catch子句包括三部分：关键字catch，圆括号内单个类型或者单个对象的声明，称为异常说明符（exception specifier），以及通常用花括号括起来的语句块。如果选择了一个catch子句来处理异常，则执行相关的块语句。一旦catch子句执行结束，程序流程立即继续执行紧随着最后一个catch子句的语句。try语句内的program-statement形成程序的正常逻辑。这里面可以包含任意C++语句，包括变量声明。与其他语句一样，try块引入局部作用域，在try块中声明的变量，包括catch子句中声明的变量，不能在try外面引用。

113、对于111中抛出的错误，与用户交互的部分可能会包括以下代码：
    while(cin >> item1 >> item2 ){
        try{
        // execute code that will add the two Sales_items
        // if the addition fails, the code throws a runtime_error exception
    } catch(runtime_error err){
        // remind the user that ISBN must match and prompt for another pair
        cout << err.what()
                << “\nTry Again? Enter y or n” << endl;
        char c;
        cin >> c;
        if(cin && c == ‘n’)
            break;      //break out of the while loop
    }
}
通过输出err.what()的返回值提示用户。这里what返回的C风格字符串，是用于初始化runtime_error的string对象的副本。

114、在复杂的系统中，程序的执行路径也许在遇到抛出异常的代码之前，就已经经过了多个try块。例如一个try块可能调用了包含另一try块的函数，它的try块又调用了含有try块的另一函数，如此类推。
    寻找处理代码的过程与函数调用链刚好相反。抛出一个异常时，首先要搜索的是抛出异常的函数。如果没有找到匹配的catch，则终止这个函数的执行，并在调用这个函数的函数中寻找相配的catch。如果仍然没有找到相应的处理代码，该函数同样要终止，搜索调用它的函数。如此类推，继续按执行路径回退，直到找到适当类型的catch为止。
    如果不存在处理该异常的catch子句，程序的运行就要跳转到名为terminate的标准库函数，该函数在exception头文件中定义。通常情况下，其执行将导致程序非正常退出。
※※※抛出异常的语句要在try中···不然会挂掉的。

115、C++标准库定义了一组类，用于报告在标准库中函数遇到的问题。程序员可在自己编写的程序中使用这些标准异常类。exception头文件定义了最常见的异常类，类名是exception。这个类只通知异常的产生，不会提供更多的信息。stdexcept头文件定义了几种常见的异常类。new头文件定义了bad_alloc异常类型，提供因无法分配内存而由new抛出的异常。type_info头文件定义了bad_cast异常类型。
116、标准库异常类只提供很少的操作，包括创建、赋值异常类型对象以及异常类型对象的赋值。exception、bad_alloc以及bad_cast类型只定义了默认构造函数，无法在创建这些类型的对象时为它们提供初值。其他的异常类则只定义了一个使用string初始化式的构造函数，用于为所发生的错误提供更多的信息。
    异常类型只定义了一个名为what的操作。这个函数不需要任何参数，并且返回const char*类型的值。它返回的指针指向一个C风格字符串，用来提供对异常的更详细的文字描述。

117、C++程序员有时候也会使用预处理技术来有条件地执行用于调试的代码。这种想法是：程序所包含的调试代码仅在开发过程中执行，当应用程序已经完成，并且准备提交时，就会将调试代码关闭。可使用NDEBUG预处理变量实现有条件的调试代码。
    int main(){
    #ifndef NDEBUG
    cerr << “starting main” << endl;
    #endif
    // .......
如果NDEBUG未定义，那么程序就会将信息写到cerr中。如果NDEBUG已经定义了，那么程序执行时将会跳过#ifndef和#endif之间的代码。

118、预处理器还定义了其余四在调试时非常有用的常量：
_ _FILE_ _ 文件名              _ _LINE_ _ 当前行号
_ _TIME_ _ 文件被编译的时间     _ _DATE_ _ 文件被编译的日期

119、另一个常见的调试技术是使用NDEBUG预处理变量以及assert（断言）预处理宏（preprocessor macro）。assert宏是在cassert头文件中定义的。预处理宏有点像函数调用。assert宏需要一个表达式作为它的条件： assert（expr）
只要NDEBUG未定义，assert宏就求解表达式expr，如果结果为false，assert输出信息并且终止程序的执行。如果该表达式有一个非零，则assert不做任何操作。在成品代码中，assert语句不做任何工作，因此也没有任何运行时的代价。当然，也不会引起任何运行时的检查。assert仅用于检查确实不可能的条件，这只对程序的测试有帮助，但不能用来代替运行时的逻辑检查，也不能代替对程序可能产生的错误检测。

120、函数可以看作程序员定义的操作。与内置操作符相同的是，每个函数都会实现一系列的计算。但与操作符不同的是，函数是有自己的函数名，而且操作数没有数量限制。与操作符一样，函数可以重载，这意味着同样的函数名可以对应多个不同的函数。

121、函数不能返回另一个函数或者内置数组类型，但可以返回指向函数的指针，或者指向数组元素的指针的指针。C++是一种静态强类型语言，对于每一次的函数调用，编译时都会检查其实参。

122、每次调用函数时，都会重新创建该函数所有的形参，此时所传递的实参将会初始化对应的形参。型材的初始化与变量的初始化一样：如果形参具有非引用类型，则赋值实参的值，如果形参为引用类型，则它只是实参的别名。

123、普通的非引用类型的参数通过复制对应的实参实现初始化。当用实参副本初始化形参时，函数并没有访问调用所传递的实参本身，因此不会修改实参的值。非引用形参表示对应实参的局部副本。对这类形参的修改仅仅改变了局部副本的值。一旦函数执行结束，这些局部变量的值也就没有了。


124、指针形参是指向const类型还是非const类型，将影响函数调用所使用的实参。在调用函数时，如果该函数使用非引用的非const形参，则既可给该函数传递const实参，也可传递非const的实参。

125、复制实参并不是在所有的情况下都适合，不适合复制实参的情况包括：
当需要在函数中修改实参的值时。
当需要以大型对象作为实参传递时。对实际的应用而言，复制对象所付出的时间和存储空间代价往往过大。
当没有办法实现对象的复制时。
对于上述几种情况，有效的解决办法是将形参定义为引用或指针类型。

126、如果想要在函数中交换实参的值，需要将形参定义为引用类型：
    void swap(int &v1,int &v2){
    int temp = v2; v2 = v1; v1 =  temp;
    }
与所有引用一样，引用形参直接关联到其所绑定的对象，而非这些对象的副本。定义引用时，必须用与该引用绑定的对象初始化该引用。引用形参完全以相同的方式工作。每次调用函数，引用形参被创建并与相应实参关联。

127、使用引用形参返回额外的信息。例如，定义一个find_val函数，在一个整型vector对象的元素中搜索某个特定值。如果找到满足要求的元素，则返回指向该元素的迭代器；否则返回一个迭代器，执行该vector对象的end操作返回的元素。此外，如果该值出现了不止一次，我们还希望函数可以返回其出现的次数。在这种情况下，返回的迭代器应该指向具有要寻找的值的第一个元素。
我们可以定义一种包含一个迭代器和一个计数器的新类型。而更简便的解决方案给find_val传递一个额外的引用实参，用于返回出现册数的统计结果。
// returns an iterator that refers to the first occurrence of value
// the reference parameter occurs contains a second return value
vector<int>::const_iterator find_val(
    vector<int>::const_iterator beg,        // first element
    vector<int>::const_iterator end,        // one past last element
    int value,                  // the value we want
    vector<int>::size_type &occurs)     // number of times it occurs
{
    // res_iter will hold first occurrence, if any
    vector<int>::const_iterator res_iter = end;
    occurs = 0;                 // set occurrence count parameter
    for( ; beg != end; ++beg)
        if(*beg == value) {
            // remember first occurrence of value
            if(res_iter == end)
            res_iter = beg;
            ++occurs;               // increment occurrence count
    }
    return res_iter;                // count returned implicitly in occurs
}
调用find_val时，需传递四个实参：一对标识vector对象中要搜索的元素范围的迭代器，所查找的值，以及用于存储出现次数的size_type类型对象。假设ivec是vecter<int>类型的对象，it是一个适当类型的迭代器，而ctr则是size_type类型的变量，则可如此调用该函数：  it = find_val(ivec.begin(), ivec.end(), 42, ctr);
调用后，ctr的值将是42出现的次数，如果42在ivec中出现了，则it将指向其第一次出现的位置；否则it的值为ivec.end()，而ctr则为0。

128、在向函数传递大型对象时，需要使用引用形参，对于大部分的类类型或者大型数组，复制实参的效率就太低了，此时就可以利用const引用直接访问实参对象，无须复制。
※※※如果使用引用形参的唯一目的是避免复制实参，则应将形参定义为const引用。

129、应该将不需要修改的引用形参定义为const引用。普通的非const引用形参在使用时不太灵活。这样的形参既不能用const对象初始化，也不能用字面值或产生右值的表达式实参初始化。

130、通常，函数不应该有vector或其他标准库容器类型的形参。。调用含有普通的非引用vector形参的函数将会复制vector的每一个元素。从避免复制vector的角度出发，应考虑将形参声明为引用类型。事实上，C++程序员倾向于通过传递指向容器中需要处理的元素的迭代器来传递容器。
    // pass iterators to the first and one past the last element to print
    void print(vector<int>::const_iterator beg,
        vector<int>::const_iterator end){
    while (beg != end){
        cout << *beg++;
        if (beg != end)   cout << “ ”;  // no space after last element
    }
    cout << endl;
    }

131、通常，将数组形参直接定义为指针要比使用数组语法定义更好。这样就明确地表示，函数操纵的是指向数组元素的指针，而不是数组本身。由于护绿了数组长度，形参定义中如果包含了数组长度则特别容易引起误解。当编译器检查数组形参关联的实参时，它只会检查实参是不是指针、指针的类型和数组元素的类型是否匹配，而不会检查数组的长度。

132、若形参是数组的引用，编译器不会将数组实参抓化为指针，而是传递数组的引用本身。在这种情况下，数组大小称为形参和实参类型的一部分。编译器检查数组实参的大小与形参大小是否相配。

133、和其他数组一样，多为数组以指向0号元素的指针方式传递。多维数组的元素本身就是数组。除了第一维以外的所有维德长度都是元素类型的一部分，必须明确指定：
    // first parameter is an array whose elements are arrays of 10 ints
    void printValues(int (matrix*)[10], int rowSize);
除了第一维以外的所有维德长度都是元素类型的一部分，必须明确指定。我们也可以用数组语法定义多维数组。与一维数组一样，编译器忽略第一维的长度，所以最好不要把它包括在形参表内。

134、非引用数组形参的类型检查只是确保实参是和数组元素具有同样类型的指针，而不会检查实参实际上是否指向指定大小的数组。任何处理数组的程序都要确保程序停留在数组的边界内。

135、有三种常见的编程技巧确保函数的操作部超出数组实参的边界。第一种方法是在数组本身放置一个标记来检测数组的结束。C风格字符串就是采用这种方法的一个例子。第二种方法是传递指向数组第一个和最后一个元素的下一个位置的指针，这样就可以确定一个元素范围，程序就会安全。点钟方法是将第二个形参定义为表示数组的大小，即显示传递表示数组大小的形参。

136、return语句用于结束当前正在执行的函数，并将控制权返回给调用此函数的函数。可以返回值，也可以不返回。不带返回值的return语句只能用于返回类型为void的函数。在返回类型为void的函数中，return返回语句不是必需的，隐式的return发生在函数的最后一个语句完成时。一般情况下，返回类型是void的函数使用return语句是为了引起函数的强制结束。在含有return语句的循环后没有提供return语句是很危险的，因为大部分的编译器不能检测出这个漏洞，运行时会出现什么问题是不确定的。

137、返回类型不是void的函数必需返回一个值，但此规则有一个例外情况：允许主函数main没有返回值就可结束。

138、返回非引用类型的时候，return都会在调用该函数的时候复制返回的对象。而返回引用类型的时候则是不复制的。

139、理解返回引用至关重要的是：千万不能返回局部变量的引用。当函数执行完毕时，将释放分配给局部对象的存储空间。此时，对局部对象的引用就会指向不确定的内存。
※※※确保返回引用安全的一个好方法是：请自问，这个引用指向哪个在此之前存在的对象？

140、函数定义就是写明具体的执行过程，声明就是告诉编译器要使用这个函数。函数声明由函数返回类型、函数名和形参列表组成。形参列表必须包括形参类型，但是不必对形参命名。这三个元素被称为函数原型（function prototype），函数原型描述了函数的接口。

141、函数也应当在头文件中声明，并在源文件中定义。定义函数的源文件应包含声明该函数的头文件。

142、因为char是整形，因此把一个char值传递给int型形参是合法的，反之亦然。

143、在C++语言中，每个名字都有作用域，而每个对象都有生命期（lifetime）。要弄清楚函数是怎么运行的，理解这两个概念十分重要。名字的作用域指的是知道该名字的程序文本区。对象的生命期则是在程序执行过程中对象存在的时间。

144、默认情况下，局部变量的生命期局限于所在函数的每次执行期间。只有当定义它的函数被调用时才存在的对象称为自动对象（automatic object）。自动对象在每次调用函数时创建和撤销。在函数结束后，自动对象和形参的值都不能再访问了。

145、一个变量如果位于函数的作用域内，但是生命期却跨域了这个函数的多次调用，这种变量往往很有用。则应该将这样的对象定义为static（静态的）。static局部对象（static local object）确保不迟于在程序执行流程第一经过该对象的定义语句时进行初始化。这种对象一旦被创建，在程序结束前都不会被撤销。当定义静态局部对象的函数结束时，静态对象不会被撤销。
    size_t count_calls(){
        static size_t ctr = 0;  // value will persist across calls
        return ++ctr;
    }
    int main(){
        for(size_t i = 0; i != 10; ++i)
            cout << cout_calls() << endl;
        return 0;
    }
依次输出1到10（包含10）的整数。

146、内联函数避免函数调用的开销，相当于在调用函数的时候用函数体替换，就可以加快速度。在函数返回类型前加上关键字inline就可以指定为内联函数。内联说明（inline specification）对于编译器来说只是一个建议，编译器可以选择忽略这个建议。一般来说，内联机制适用于优化小的、只有几行而且经常被调用的函数。大多数编译器都不支持递归函数的内联。

147、内联函数应该在头文件中定义，这一点不同于其他函数。在头文件中加入或修改内联函数时，使用了该头文件的所有泊文件都必须得重新编译。

148、成员函数的定义与普通函数的定义类似。和任何函数一样，成员函数也包含下面四个部分：函数返回类型、函数名、用逗号隔开的形参表（也可能是空的）、包含在一对花括号里面的函数体。函数原型必须在类中定义。但是，函数体则既可以在类中也可以在类外定义。类的所有成员都必须在类定义的花括号里声明，此后，就不能再为类增加任何成员。类的成员函数必须如声明的一般定义。类的成员函数既可以在类的定义内也可以在类的定义外定义。编译器隐式地将在类内定义的成员函数当作内联函数。类的成员函数可以访问该类的private成员。

149、每个成员函数（除static成员函数外）都有一个额外的、隐含的形参this。在调用成员函数时，形参this初始化为调用函数的对象的地址。

150、const对象、指向const对象的指针或引用只能调用其const成员函数，如果尝试用它们来调用非const成员函数，则是错误的。

151、在成员函数中，不必显式地使用this指针来访问被调用函数所属对象的成员。对这个类的成员的任何没有前缀的引用，都被假定为通过指针this实现的引用。

152、在类外定义成员函数就必须指明它们是类的成员
    double Sales_item::avg_price() const{
    if (units_sold)
        return revenue/units_sold;
    else
        return 0;
    }
使用作用域操作符指明函数avg_price是在类Sales_item的作用域范围内定义的。

153、构造函数（constructor）是特殊的成员函数，与其他成员函数不同，构造函数和类同名，而且没有返回类型。而与其他成员函数相同的是，构造函数也有形参表（可能为空）和函数体。一个类可以有多个构造函数，每个构造函数必须有与其他构造函数不同数目或类型的形参。构造函数也必须在类中声明，但是可以在类中或类外定义。构造函数放在类的public部分。

154、如果没有为一个类显式定义任何构造函数，编译器将自动为这个类生成默认构造函数。合成的默认构造函数一般适用于仅包含类类型成员的类。而对于含有内置类型或复合类型成员的类。则通常应该定义他们自己的默认构造函数初始化这些成员。


155、出现在相同作用域中的两个函数，如果具有相同的名字而形参表不同，则成为重载函数（overloaded function）。如果两个函数声明的返回类型和形参表完全匹配，则将第二个函数声明视为第一个的重复声明。如果两个函数的形参表完全相同，但返回类型不同，则第二个声明是错误的。

156、一般作用域规则同样适用于重载函数名。如果局部地声明一个函数，则该函数将屏蔽而不是重载在外层作用域中声明的同名函数。所以，每一个版本的重载函数都应在同一个作用域中声明。一般来说，局部地声明函数时一种不明智的选择。函数的声明应放在头文件中。在C++中，名字查找发生在类型检查之前。

157、函数重载确定（overload resolution，即函数匹配function matching）是将函数调用与重载函数集合中的一个函数相关联的过程。通过自动提取函数调用中实际使用的实参与重载集合中各个函数提供的形参做比较，编译器实现该调用与函数的匹配。

158、为了确定最佳匹配，编译器将实参类型到相应形参类型的转换划分等级。转换等级以降序排列如下：精确匹配（exact match），实参与形参类型相同。通过类型提升（promotion）实现的匹配。通过标准转换（standard conversion）实现的匹配。通过类类型转换（class-type conversion）实现的匹配。
※※※内置类型的提升和转换可能会使函数匹配产生意想不到的结果。但幸运的是，设计良好的系统很少会包含形参类型相当接近的函数。

159、类型提升或转换适用于实参类型可通过某种标准转换提升或转换为适当的形参类型的情况。通过类型提升实现的转换优于其他标准的转换。
    void ff(int);
    void ff(short);
    ff(‘a’);            // char promotes to int, so matches ff(int)

160、枚举类型enum的对象只能用同一枚举类型的另一个对象或一个枚举成员（enumerator）进行初始化。整数对象即使具有与枚举元素相同的值也不能用于调用期望获得枚举类型实参的函数。虽然无法将整型值传递给枚举类型的形参，但可以将枚举值传递给整数形参。此时，枚举值被提升为int型或更大的整形。具体的提升类型取决于枚举成员的值。

161、仅当形参是引用或指针时，形参是否为const才有影响。

162、函数指针是指指向函数而非指向对象的指针。像其他指针一样，函数指针也指向某个特定的类型。函数类型由其返回类型以及形参表确定，而与函数名无关。
    // pf points to function returning bool that takes two const string references
    bool (*pf)(const string &, const string &);
其中*pf两侧的括号是必需的。或者是使用typedef为指针类型定义同义词，可将函数指针的使用大大简化。typedef bool (*cmpFcn) (const string &, const string &);以后使用则直接用cmpFcn即可。

163、在引用函数名但又没有调用该函数时，函数名将被自动解释为指向函数的指针。函数指针只能通过同类型的函数或函数指针或0值常量表达式进行初始化或赋值。

164、指向函数的指针可用于调用它所指向的函数。可以不需要使用解引用操作符，直接通过指针调用函数。函数的形参可以是指向函数的指针。

165、endl操纵符用于输出一个换行符并刷新缓冲区。而flush，用于刷新流，但不在输出中添加任何字符。还有一个比较少用的ends，这个操作符在缓冲区插入空字符null，然后刷新它。如果需要刷新所有输出，最好使用unitbuf操作符。这个操作符在每次执行完写操作后都刷新流： cout << unitbuf << “first” << “ second” << nounitbuf;   等价于：
    cout << “first” << flush << “second” << flush;
nounitbuf操纵符将流恢复为使用正常的、由系统管理的缓冲区刷新方式。

166、如果程序不正常结束，输出缓冲区将不会刷新。在尝试调试已崩溃的程序时，通常会根据最后的输出找出程序发生错误的区域。如果崩溃出现在某个特定的输出语句后面，则可知是在程序的这个位置之后出错。
调试程序时，必须保证期待写入的每个输出都确实被刷新了。如果需要使用最后的输出给程序错误定位，则必须确定所有要输出地都已经输出。为了确保用户看到程序实际上处理的所有输出，最好的方法是保证所有的输出操作都显式地调用了flush或endl。如果仅因为缓冲区没有刷新，程序员将浪费大量的时间跟踪调试并没有执行的代码。基于这个原因，输出时应多使用endl而非‘\n’。
167、当输入流与输出流绑在一起时，任何读输入流的尝试都将首先刷新其输出流关联的缓冲区。交互式系统通常应确保它们的输入和输出流失绑在一起的。这样做意味着可以保证任何输出，包括给用户的提示，都在试图读之前输出。

168、打开文件后，通常要检验打开是否成功，这是一个好习惯。
    // check that the open succeeded
    if (!infile){
    cerr << “error: unable to open input file : ”
        << ifile << endl;
    return -1;
    }
如果程序员需要重用文件流读写多个文件，必须在读另一个文件之前调用clear清楚该流的状态。

169、C++提供了使用抽象进行高效率编程的方式。标准库就是一个很好的例子：标准库定义了许多容器类以及一系列泛型算法，使程序员可以更简洁、抽象和有效地编写程序。这样可以让标准库操心那些繁琐的细节，特别是内存管理，我们的程序只需关注要解决的实际问题就行了。泛型算法中，所谓“泛型(generic)”指的是两个方面：这些算法可作用于各种不同的容器类型，而这些容器又可以容纳多种不同类型的元素。
为容器类型提供通用接口是设计库的目的。容器提供的操作和算法是一致定义的，这使得学习标准库更容易：只需理解一个操作如何工作，就能将该操作应用于其他的容器。更重要的是，接口的一致性使程序变得更灵活。

170、标准库定义了三种顺序容器类型：vector（支持快速随机访问）、list（支持快速插入、删除）和deque（是双端队列“double-ended queue”的简写，发音为 “deck”）。它们的差别在于访问元素的方式，以及添加或删除元素相关操作的运行代价。标准库还提供了三种容器适配器（adaptor）。实际上，适配器是根据原始的容器类型所提供的操作，通过定义新的操作接口，来适应基础的容器类型。顺序容器适配器包括stack（后进先出LIFO栈）、queue（先进先出FIFO）和priority_queue类型（有优先级管理的队列）。容器只定义了少量操作。大多数额外操作则由算法库提供。标准库为由容器类型定义的操作加强了公共的接口。



171、为了定义一个容器类型的对象，必须先包含相关的头文件<vector><list><deque>所有的容器都是类模板。要定义某种特殊的容器，必须在容器名后加一对尖括号，尖括号里面提供容器中存放的元素的类型。所有的容器类型都定义了默认构造函数，用于创建指定类型的空容器对象。为了使程序更清晰、简短，容器类型最常用的构造函数是默认构造函数。在大多数的程序中，使用默认构造函数能达到最佳运行时性能，并且使容器更容易使用。

172、将一个容器复制给另一个容器时，类型必须匹配：容器类型和元素类型都必须相同。尽管不能将一种容器内的元素复制给另一种容器，但系统允许通过传递一对迭代器间接实现该功能。使用迭代器时，不要求容器类型相同。容器内的元素类型也可以不相同，只要他们相互兼容，能够将要复制的元素转换为所构建的新容器的元素类型，即可实现复制。
173、创建顺序容器时，可显式指定容器大小和一个（可选的）元素初始化式。容器大小可以使常量或非常量表达式，元素初始化式则必须是可用于初始化其元素类型的对象的值。接受容器大小做形参的构造函数只适用于顺序容器，而关联容器不支持这种初始化。

174、C++语言中，大多数类型都可用作容器的元素类型。容器元素类型必须满足以下两个约束：元素类型必须支持赋值运算；元素类型的对象必须可以复制。

175、因为容器受容器元素类型的约束，所以可定义元素是容器类型的容器。例如
    vector< vector<string> > lines;     // vector of vectors
必须用空格隔开两个相邻的 > 符号，以示这是两个分开的符号，否则，系统会认为>>是单个符号，为右移操作符，并结果导致编译时错误。

176、在整个标准库中，经常使用形参为一对迭代器的构造函数。关系操作符只适用于vector和deque容器，这是因为只有这两种容器为其元素提供快速、随机的访问。它们确保可根据元素位置直接有效地访问指定的容器元素。

177、迭代器范围这个概念是标准库的基础。C++语言使用一对迭代器标记迭代器范围（iterator range），这两个迭代器分别指向同一个容器中的两个元素或超出末端的下一位置，通常将它们命名为first和last，或beg和end，用于标记容器中的一段元素范围。称为左闭合区间（left-inclusive interval），其标准方式为：
// to be read as: includes first and each element up to but not including last
[ first, last )
当first与last相等时，迭代器范围为空；
当first与last不相等时，迭代器范围内至少有一个元素，而且first指向该区间中的第一个元素。

178、修改容器的内在状态或移动容器内的元素等操作使所有指向呗移动的元素的迭代器时效，也可能同时使其他迭代器失效。使用无效迭代器时没有定义的，可能会导致与悬垂指针相同的问题。使用迭代器编写程序时，必须留意那些操作会使迭代器失效。使用无效迭代器将会导致严重的运行时错误。

179、使用迭代器时，通常可以编写程序使得要求迭代器有效地代码发内相对较短。然后，在该范围内，严格检查每一条语句，判断是否有元素添加或删除，从而相应地调整迭代器的值。

180、除了push_back运算，list和deque容器类型还提供了类似的操作：push_front。这个操作实现再容器首部插入新元素的功能。

181、再容器中添加元素时，系统是将元素值复制到容器里。类似地，使用一段元素初始化新容器时，新荣期存放的是原始元素的副本。被复制的原始值与新荣期中的元素各不相关，此后，容器内元素值发生变化时，被复制的原值不会收到影响，反之亦然。

182、insert曹走提供了一组更通用的插入方法，实现在容器的任意指定位置插入新元素。
c.insert(p,t) 在迭代器p所指向的元素前面插入值为t的新元素。返回指向新添加元素的迭代器
c.insert(p,n,t) 在迭代器p所指向的元素前面插入n个值为t的新元素。返回void类型
c.insert(p,b,e) 在迭代器p所指向的元素前面插入由迭代器b和e标记的范围内的元素。返回void类型

183、任何insert或push操作都可能导致迭代器失效。当编写循环将元素插入到vector或deque容器中时，程序必须确保迭代器在每次循环后都得到更新。

184、在vector或deque容器中添加元素时，可能会导致某些或全部迭代器失效。假设所有迭代器失效是最安全的做法。这个建议特别适用于由end操作返回的迭代器。在容器的任何位置插入任何元素都会使该迭代器失效。为了避免存储end迭代器，可以在每次做完插入运算后重新计算。
     // safer:recalculate end on each trip whenever the loop adds/erases elements
     while (first != v.end()){
           // do some processing
           first = v.insert(first, 42); // insert new value
           ++first; // advance first just past the element we added
     }

185、所有的容器类型都支持用关系操作符来实现两个容器的比较。比较的容器必须具有相同的容器类型，而且其元素类型也必须相同。
如果两个容器具有相同的长度而且所有元素都相等，那么这两个容器就相等；否则，它们就不相等。
如果两个容器的长度不相同，但较短的容器中所有元素都等于较长容器中对应的元素，则称较短的容器小于另一个容器。
如果两个容器都不是对方的初始子序列，则它们的比较结果取决于所比较的第一个不相等的元素。

186、顺序容器大小的操作
c.max_size()      返回容器c可容纳的最多元素个数，返回类型为c::size_type
c.resize(n)          调整容器c的长度大小，使其能容纳n个元素，如果n<c.size()，则删除多出来的元素；否则，添加采用值初始化的新元素
c.resize(n,t)        调整容器c的大小，使其能容纳n个元素。所有新添加的元素值都为t

187、resize操作可能会使迭代器失效。在vector或deque容器上做resize操作有可能会使所有的迭代器都失效。对于所有的容器类型，如果resize操作压缩了容器，则指向已删除的元素的迭代器失效。

188、如果容器非空，那么容器类型的front和back成员将返回容器内第一个或最后一个元素的引用。使用越界的下标，或调用空容器的front或back函数，都会导致程序出现严重的错误。使用下标运算的另一个可选方案是at成员函数。这个函数的行为和下标运算相似，但是如果给出的下标无效，at函数将会抛出out_of_range异常。

189、容器类型提供了通用的insert操作在容器的任何位置插入元素，并支持特定的push_front和push_back操作在容器首部或尾部插入新元素。类似地，容器类型提供了通用的erase操作和特定的pop_front和pop_back操作来删除容器内的元素。
c.erase( k )            删除迭代器 k 所指向的元素。返回一个迭代器，它指向被删除元素后面的元素，若 k 指向容器容器内的最后一个元素，则返回的迭代器指向容器的超出末端的下一位置。如果 k 本身就是指向超出末端的下一位置的迭代器，则该函数未定义。
c.erase( b,e )         删除迭代器 b 和 e 所标记的范围内所有的元素。返回一个迭代器，它指向被删除元素段后面的元素。如果 e 本身就是指向超出末端的下一位置的迭代器，那么返回的迭代器也指向容器超出末端的下一位置。
c.clear()                 删除容器 c 内的所有元素。返回void
c.pop_back()         删除容器 c 的最后一个元素。返回void。如果 c 为空容器，则该函数未定义。
c.pop_front()          删除容器 c 的第一个元素。返回void。如果 c 为空容器，则该函数未定义。
      以上两个只能用于list或deque容器

190、pop_front操作通常与front操作配套使用，实现以桟的方式处理容器：
         while (!ilist.empty()) {
                   process(ilist.front());      // do something with the current top of ilist
                   ilist.pop_front();       // done;remove first element
         }
这个循环非常简单：使用front操作获取要处理的元素，然后调用pop_front函数从容器list中删除该元素。pop_front和pop_back函数的返回值并不是删除的元素的值，而是void。要获取删除的元素值，则必须在删除元素之前调用front或back函数。

191、删除一个或一段元素更通用的方法是erase操作。如同其他操作一样，erase操作也不会检查它的参数。必须确保迭代器是有效的。

192、赋值和 assign 操作使得作操作数容器的所有迭代器失效。swap 操作则不会使迭代器失效。完成 swap 后，尽管被交换的元素已经存放在另一容器中，但迭代器仍然指向相同的元素。

193、顺序容器的赋值操作
c1 ＝ c2            删除容器 c1 的所有元素，然后将 c2 的元素复制给 c1。c1 和 c2 的类型（包括容器类型和元素类型）必须相同。
c1.swap(c2)      交换内容：调用完该函数后，c1 中存放的是 c2 原来的元素，c2中存放的则是 c1原来的元素。c1 和 c2 的类型必须相同。该函数的执行速度通常要比将 c2 的元素复制到 c1 的操作快。
c.assign(b,e)     重新设置 c 中的元素：将迭代器 b 和 e 标记的范围内所有的元素复制到 c 中。b 和 e 必须不是指向 c 中元素的迭代器。
c.assign(n,t)      将容器 c 重新设置为存储 n 各值为 t 的元素

194、是用 swap 操作以节省删除元素的成本，并且迭代器不会失效，原来指向哪里，现在还是指向哪里。

195、在容器对象中 insert 或压入一个元素时，该对象的大小增加 1。类似地，如果 resize 容器以扩充其容量，则必须在容器中添加额外的元素。比起 list 和 deque 容器，vector 的增长效率通常会更高。会为 vector 预留额外的存储区。

196、capacity 操作获取在容器需要分配更多的存储空间之前能够存储的元素总数，而 reserve 操作则告诉 vector 容器应该预留多少个元素的存储空间。size 指容器当前拥有的元素个数。每当 vector 容器不得不分配新的存储空间时，以加倍当前容量分配策略实现重新分配。vector 的每种实现都可自由地选择自己的内存分配策略。然后，它们都必须提供 reserve 和 capacity 函数，而且必须时到必要时才分配新的内存空间。分配多少内存取决于其实现方式。不同的库采用不同的策略实现。此外，每种实现都要求遵循以下原则：确保 push_back 操作高效地在 vector 中添加元素。从技术上说，在原来为空的 vector 容器上 n 次调用 push_back 函数，从而创建拥有 n 个元素的 vector 容器，其执行时间永远不能超过 n 的常量倍。
